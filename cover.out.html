
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/fasdalf/train-go-musthave-metrics/cmd/agent/main.go (0.0%)</option>
				
				<option value="file1">github.com/fasdalf/train-go-musthave-metrics/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/fasdalf/train-go-musthave-metrics/cmd/staticlint/errcheckanalyzer.go (100.0%)</option>
				
				<option value="file3">github.com/fasdalf/train-go-musthave-metrics/cmd/staticlint/main.go (0.0%)</option>
				
				<option value="file4">github.com/fasdalf/train-go-musthave-metrics/cmd/staticlint/osexitanalyzer.go (100.0%)</option>
				
				<option value="file5">github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers/collectGopsutilMetrics.go (0.0%)</option>
				
				<option value="file6">github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers/collectLoop.go (61.5%)</option>
				
				<option value="file7">github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers/collectMetrics.go (100.0%)</option>
				
				<option value="file8">github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers/mockposter.go (100.0%)</option>
				
				<option value="file9">github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers/nethttpposter.go (73.2%)</option>
				
				<option value="file10">github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers/restyposter.go (76.0%)</option>
				
				<option value="file11">github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers/sendMetrics.go (100.0%)</option>
				
				<option value="file12">github.com/fasdalf/train-go-musthave-metrics/internal/common/configfile/configfile.go (100.0%)</option>
				
				<option value="file13">github.com/fasdalf/train-go-musthave-metrics/internal/common/cryptofacade/cryptofacade.go (100.0%)</option>
				
				<option value="file14">github.com/fasdalf/train-go-musthave-metrics/internal/common/jsonofflinestorage/jsonofflinesaver.go (0.0%)</option>
				
				<option value="file15">github.com/fasdalf/train-go-musthave-metrics/internal/common/localip/localip.go (100.0%)</option>
				
				<option value="file16">github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage/dbStorage.go (0.0%)</option>
				
				<option value="file17">github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage/dirtystorage.go (100.0%)</option>
				
				<option value="file18">github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage/memStorage.go (100.0%)</option>
				
				<option value="file19">github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage/memStorageMuted.go (100.0%)</option>
				
				<option value="file20">github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage/mockErrorStorage.go (100.0%)</option>
				
				<option value="file21">github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage/modelStorage.go (90.0%)</option>
				
				<option value="file22">github.com/fasdalf/train-go-musthave-metrics/internal/common/mockreaders/errcloser.go (100.0%)</option>
				
				<option value="file23">github.com/fasdalf/train-go-musthave-metrics/internal/common/mockreaders/errreader.go (100.0%)</option>
				
				<option value="file24">github.com/fasdalf/train-go-musthave-metrics/internal/common/printbuild/printbuild.go (100.0%)</option>
				
				<option value="file25">github.com/fasdalf/train-go-musthave-metrics/internal/common/retryattempt/retryattempt.go (100.0%)</option>
				
				<option value="file26">github.com/fasdalf/train-go-musthave-metrics/internal/common/rsacrypt/rsacrypt.go (83.3%)</option>
				
				<option value="file27">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/checkMetricExistenceHandler.go (100.0%)</option>
				
				<option value="file28">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/compressWriter.go (0.0%)</option>
				
				<option value="file29">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/cryptoreader.go (100.0%)</option>
				
				<option value="file30">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/decryptBodyHandler.go (100.0%)</option>
				
				<option value="file31">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/gzipCompressionHandler.go (0.0%)</option>
				
				<option value="file32">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/hashWriter.go (0.0%)</option>
				
				<option value="file33">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/index.go (58.3%)</option>
				
				<option value="file34">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/loggingResponseWriter.go (0.0%)</option>
				
				<option value="file35">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/metricValueResponseHandler.go (97.1%)</option>
				
				<option value="file36">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/pingDBHandler.go (0.0%)</option>
				
				<option value="file37">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/respondWithHashHandler.go (0.0%)</option>
				
				<option value="file38">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/saveMetricHandler.go (0.0%)</option>
				
				<option value="file39">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/saveMetricsHandler.go (0.0%)</option>
				
				<option value="file40">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/slogHandler.go (0.0%)</option>
				
				<option value="file41">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/updateMetric.go (100.0%)</option>
				
				<option value="file42">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/validateHashHandler.go (0.0%)</option>
				
				<option value="file43">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/validateiphandler.go (100.0%)</option>
				
				<option value="file44">github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers/viewMetric.go (67.6%)</option>
				
				<option value="file45">github.com/fasdalf/train-go-musthave-metrics/internal/server/httpServer.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log/slog"
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/fasdalf/train-go-musthave-metrics/internal/agent/config"
        "github.com/fasdalf/train-go-musthave-metrics/internal/agent/handlers"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/printbuild"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/retryattempt"
)

var (
        buildVersion string
        buildDate    string
        buildCommit  string
)

func main() <span class="cov0" title="0">{
        const pprofHTTPAddr = ":8092"

        bd := &amp;printbuild.Data{
                BuildVersion: buildVersion,
                BuildDate:    buildDate,
                BuildCommit:  buildCommit,
        }
        bd.Print()

        cfg := config.GetConfig()
        collectInterval := time.Duration(cfg.PollInterval) * time.Second
        sendInterval := time.Duration(cfg.ReportInterval) * time.Second
        memStorage := metricstorage.NewMemStorageMuted()
        retryer := retryattempt.NewRetryer([]time.Duration{1 * time.Second, 3 * time.Second, 5 * time.Second})
        ctx, cancel := context.WithCancel(context.Background())
        poster := handlers.NewNetHTTPPoster(cfg.Addr, cfg.HashKey, cfg.RSAKey)

        wg := new(sync.WaitGroup)
        wg.Add(3)
        go handlers.SendMetricsLoop(ctx, wg, memStorage, sendInterval, retryer, poster, cfg.RateLimit)
        go handlers.Collect(handlers.CollectMetrics, ctx, wg, memStorage, collectInterval)
        go handlers.Collect(handlers.CollectGopsutilMetrics, ctx, wg, memStorage, collectInterval)
        // for "net/http/pprof"
        go http.ListenAndServe(pprofHTTPAddr, nil)
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)
        &lt;-quit
        slog.Info("interrupt signal received")
        signal.Stop(quit)
        cancel()
        slog.Info("attempting graceful shutdown")
        wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "database/sql"
        "errors"
        "log/slog"
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/jsonofflinestorage"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/metricstorage"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/printbuild"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/retryattempt"
        "github.com/fasdalf/train-go-musthave-metrics/internal/server"
        "github.com/fasdalf/train-go-musthave-metrics/internal/server/config"
        "github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers"
        _ "github.com/jackc/pgx/v5/stdlib"
)

var (
        buildVersion string
        buildDate    string
        buildCommit  string
)

func main() <span class="cov0" title="0">{
        const pprofHTTPAddr = ":8093"

        bd := &amp;printbuild.Data{
                BuildVersion: buildVersion,
                BuildDate:    buildDate,
                BuildCommit:  buildCommit,
        }
        bd.Print()

        ctx, ctxCancel := context.WithCancel(context.Background())
        wg := &amp;sync.WaitGroup{}
        c := config.GetConfig()
        slog.Info("initializing server")

        retryer := retryattempt.NewRetryer([]time.Duration{1 * time.Second, 3 * time.Second, 5 * time.Second})
        var metricStorage *metricstorage.SavableModelStorage

        var db handlers.Pingable

        switch true </span>{
        case c.StorageDBDSN != "":<span class="cov0" title="0">
                slog.Info("initializing database connection", "DATABASE_DSN", c.StorageDBDSN)
                var err error
                pgx, err := sql.Open("pgx", c.StorageDBDSN)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("can not connect to DB", "error", err)

                        panic(err)</span>
                }

                <span class="cov0" title="0">defer pgx.Close()

                dbStorage, err := metricstorage.NewDBStorage(pgx, context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("can not init DB", "error", err)
                        panic(err)</span>
                }
                <span class="cov0" title="0">metricStorage = metricstorage.NewSavableModelStorage(dbStorage)
                db = pgx</span>
        case c.StorageFileName != "":<span class="cov0" title="0">
                slog.Info("initializing in-mem and in-file storage")
                dirtyStorage := metricstorage.NewDirtyStorage(metricstorage.NewMemStorage())
                modelStorage := metricstorage.NewSavableModelStorage(dirtyStorage)

                slog.Info("initializing file storage")
                fileSaver := jsonofflinestorage.NewJSONFileStorage(modelStorage, c.StorageFileName, c.StorageFileRestore, c.StorageFileStoreInterval, dirtyStorage.SavedChan, dirtyStorage.Clear)
                if err := fileSaver.Start(ctx, wg); err != nil </span><span class="cov0" title="0">{
                        slog.Error("can not init file storage", "error", err)
                        panic(err)</span>
                }
                <span class="cov0" title="0">metricStorage = modelStorage</span>
        default:<span class="cov0" title="0">
                slog.Info("initializing in-mem only storage")
                metricStorage = metricstorage.NewSavableModelStorage(metricstorage.NewMemStorage())</span>
        }

        <span class="cov0" title="0">slog.Debug("initializing http router")
        engine := server.NewRoutingEngine(metricStorage, db, retryer, c.HashKey, c.RSAKey, c.TrustedSubnet)
        srv := &amp;http.Server{
                Addr:    c.Addr,
                Handler: engine,
        }

        // for "net/http/pprof"
        go http.ListenAndServe(pprofHTTPAddr, nil)

        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)

        go func() </span><span class="cov0" title="0">{
                &lt;-quit
                slog.Info("interrupt signal received")
                signal.Stop(quit)
                ctxCancel()
                if err := srv.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Server shutdown error:", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">slog.Info("starting http server", "address", c.Addr)
        if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        slog.Info("Server closed by interrupt signal")
                        slog.Info("wait for bg processes")
                        wg.Wait()
                }</span> else<span class="cov0" title="0"> {
                        slog.Error("server not started or stopped with error", "error", err)
                        panic(err)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "go/ast"
        "go/types"

        "golang.org/x/tools/go/analysis"
)

var ErrCheckAnalyzer = &amp;analysis.Analyzer{
        Name: "errcheck",
        Doc:  "check for unchecked errors",
        Run:  runErrCheckAnalyzer,
}

func runErrCheckAnalyzer(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        expr := func(x *ast.ExprStmt) </span><span class="cov8" title="1">{
                // проверяем, что выражение представляет собой вызов функции,
                // у которой возвращаемая ошибка никак не обрабатывается
                if call, ok := x.X.(*ast.CallExpr); ok </span><span class="cov8" title="1">{
                        if isReturnError(pass, call) </span><span class="cov8" title="1">{
                                pass.Reportf(x.Pos(), "expression returns unchecked error")
                        }</span>
                }
        }
        <span class="cov8" title="1">tuplefunc := func(x *ast.AssignStmt) </span><span class="cov8" title="1">{
                // рассматриваем присваивание, при котором
                // вместо получения ошибок используется '_'
                // a, b, _ := tuplefunc()
                // проверяем, что это вызов функции
                if call, ok := x.Rhs[0].(*ast.CallExpr); ok </span><span class="cov8" title="1">{
                        results := resultErrors(pass, call)
                        for i := 0; i &lt; len(x.Lhs); i++ </span><span class="cov8" title="1">{
                                // перебираем все идентификаторы слева от присваивания
                                if id, ok := x.Lhs[i].(*ast.Ident); ok &amp;&amp; id.Name == "_" &amp;&amp; results[i] </span><span class="cov8" title="1">{
                                        pass.Reportf(id.NamePos, "assignment with unchecked error")
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">errfunc := func(x *ast.AssignStmt) </span><span class="cov8" title="1">{
                // множественное присваивание: a, _ := b, myfunc()
                // ищем ситуацию, когда функция справа возвращает ошибку,
                // а соответствующий идентификатор слева равен '_'
                for i := 0; i &lt; len(x.Lhs); i++ </span><span class="cov8" title="1">{
                        if id, ok := x.Lhs[i].(*ast.Ident); ok </span><span class="cov8" title="1">{
                                // вызов функции справа
                                if call, ok := x.Rhs[i].(*ast.CallExpr); ok </span><span class="cov8" title="1">{
                                        if id.Name == "_" &amp;&amp; isReturnError(pass, call) </span><span class="cov8" title="1">{
                                                pass.Reportf(id.NamePos, "assignment with unchecked error")
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">for _, file := range pass.Files </span><span class="cov8" title="1">{
                // функцией ast.Inspect проходим по всем узлам AST
                ast.Inspect(file, func(node ast.Node) bool </span><span class="cov8" title="1">{
                        switch x := node.(type) </span>{
                        case *ast.ExprStmt:<span class="cov8" title="1"> // выражение
                                expr(x)</span>
                        case *ast.GoStmt:<span class="cov8" title="1"> // go myfunc()
                                if isReturnError(pass, x.Call) </span><span class="cov8" title="1">{
                                        pass.Reportf(x.Pos(), "go statement with unchecked error")
                                }</span>
                        case *ast.DeferStmt:<span class="cov8" title="1"> // defer myfunc()
                                if isReturnError(pass, x.Call) </span><span class="cov8" title="1">{
                                        pass.Reportf(x.Pos(), "defer with unchecked error")
                                }</span>
                        case *ast.AssignStmt:<span class="cov8" title="1"> // оператор присваивания
                                if len(x.Rhs) == 1 </span><span class="cov8" title="1">{ // справа одно выражение x,y := myfunc()
                                        tuplefunc(x)
                                }</span> else<span class="cov8" title="1"> { // справа несколько выражений x,y := z,myfunc()
                                        errfunc(x)
                                }</span>
                        }
                        <span class="cov8" title="1">return true</span>
                })
        }
        <span class="cov8" title="1">return nil, nil</span>
}

var errorType = types.
        // ищем тип error в области вилимости Universe, в котором находятся
        // все предварительно объявленные объекты Go
        Universe.Lookup("error").
        // получаем объект, представляющий тип error
        Type().
        // получаем тип, при помощи которого определен тип error (см. https://go.dev/ref/spec#Underlying_types);
        // мы знаем, что error определен как интерфейс, приведем полученный объект к этому типу
        Underlying().(*types.Interface)

func isErrorType(t types.Type) bool <span class="cov8" title="1">{
        // проверяем, что t реализует интерфейс, при помощи которого определен тип error,
        // т.е. для типа t определен метод Error() string
        return types.Implements(t, errorType)
}</span>

// resultErrors возвращает булев массив со значениями true,
// если тип i-го возвращаемого значения соответствует ошибке.
func resultErrors(pass *analysis.Pass, call *ast.CallExpr) (r []bool) <span class="cov8" title="1">{
        r = []bool{false}
        switch t := pass.TypesInfo.Types[call].Type.(type) </span>{
        case *types.Named:<span class="cov8" title="1"> // возвращается значение
                r = []bool{isErrorType(t)}</span>
        case *types.Pointer:<span class="cov8" title="1"> // возвращается указатель
                r = []bool{isErrorType(t)}</span>
        case *types.Tuple:<span class="cov8" title="1"> // возвращается несколько значений
                s := make([]bool, t.Len())
                for i := 0; i &lt; t.Len(); i++ </span><span class="cov8" title="1">{
                        switch mt := t.At(i).Type().(type) </span>{
                        case *types.Named:<span class="cov8" title="1">
                                s[i] = isErrorType(mt)</span>
                        case *types.Pointer:<span class="cov8" title="1">
                                s[i] = isErrorType(mt)</span>
                        }
                }
                <span class="cov8" title="1">r = s</span>
        }
        <span class="cov8" title="1">return</span>
}

// isReturnError возвращает true, если среди возвращаемых значений есть ошибка.
func isReturnError(pass *analysis.Pass, call *ast.CallExpr) bool <span class="cov8" title="1">{
        for _, isError := range resultErrors(pass, call) </span><span class="cov8" title="1">{
                if isError </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "honnef.co/go/tools/simple"
        "honnef.co/go/tools/staticcheck"
)

func main() <span class="cov0" title="0">{
        // определяем map подключаемых правил
        checks := map[string]bool{
                "S1001": true,
        }
        mychecks := []*analysis.Analyzer{
                // ##@@
                //ErrCheckAnalyzer,
                printf.Analyzer,
                shadow.Analyzer,
                shift.Analyzer,
                structtag.Analyzer,
                OSExitAnalyzer,
        }

        for _, v := range staticcheck.Analyzers </span><span class="cov0" title="0">{
                // добавляем в массив "нужные" проверки
                mychecks = append(mychecks, v.Analyzer)
        }</span>

        <span class="cov0" title="0">for _, v := range simple.Analyzers </span><span class="cov0" title="0">{
                // добавляем в массив "нужные" проверки
                if checks[v.Analyzer.Name] </span><span class="cov0" title="0">{
                        mychecks = append(mychecks, v.Analyzer)
                }</span>
        }

        <span class="cov0" title="0">multichecker.Main(
                mychecks...,
        )</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "go/ast"

        "golang.org/x/tools/go/analysis"
)

var OSExitAnalyzer = &amp;analysis.Analyzer{
        Name: "osexit",
        Doc:  "check for os.Exit in main()",
        Run:  runOSExitAnalyzer,
}

func runOSExitAnalyzer(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        for _, file := range pass.Files </span><span class="cov8" title="1">{
                if file.Name.String() != "main" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">isMain := false
                ast.Inspect(file, func(n ast.Node) bool </span><span class="cov8" title="1">{
                        switch x := n.(type) </span>{
                        case *ast.CallExpr:<span class="cov8" title="1">
                                if s, ok := x.Fun.(*ast.SelectorExpr); ok </span><span class="cov8" title="1">{
                                        if s.Sel.Name == "Exit" </span><span class="cov8" title="1">{
                                                if i, ok := s.X.(*ast.Ident); ok </span><span class="cov8" title="1">{
                                                        if i.Name == "os" </span><span class="cov8" title="1">{
                                                                pass.Reportf(s.Pos(), "call to os.Exit in main")
                                                        }</span>
                                                }
                                        }
                                }
                        case *ast.FuncDecl:<span class="cov8" title="1">
                                isMain = x.Name.Name == "main"
                                return isMain</span>
                        }
                        <span class="cov8" title="1">return true</span>
                })
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "strconv"
        "time"

        "github.com/shirou/gopsutil/v4/cpu"
        "github.com/shirou/gopsutil/v4/mem"
)

// CollectGopsutilMetrics collects various metrics to given storage
func CollectGopsutilMetrics(s Storage, collectInterval time.Duration) error <span class="cov0" title="0">{
        vmem, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.UpdateGauge("TotalMemory", float64(vmem.Total))
        s.UpdateGauge("FreeMemory", float64(vmem.Free))
        cpus, err := cpu.Percent(collectInterval, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for i, percent := range cpus </span><span class="cov0" title="0">{
                s.UpdateGauge("CPUutilization"+strconv.Itoa(i+1), percent)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "context"
        "log/slog"
        "sync"
        "time"
)

type callback = func(s Storage, collectInterval time.Duration) error

func loop(c func(), ctx context.Context, wg *sync.WaitGroup, i time.Duration) <span class="cov8" title="1">{
        defer wg.Done()
        timer := time.NewTimer(i + 1)
        defer timer.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-timer.C:<span class="cov8" title="1"></span>
                }
                <span class="cov8" title="1">c()
                timer.Reset(i)</span>
        }
}

func Collect(c callback, ctx context.Context, wg *sync.WaitGroup, storage Storage, collectInterval time.Duration) <span class="cov0" title="0">{
        cb := func() </span><span class="cov0" title="0">{
                if err := c(storage, collectInterval); err != nil </span><span class="cov0" title="0">{
                        slog.Error(`collector error`, `err`, err)
                }</span>
                <span class="cov0" title="0">slog.Info(`collector sleeping`, `delay`, collectInterval)</span>
        }
        <span class="cov0" title="0">loop(cb, ctx, wg, collectInterval)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "log/slog"
        "math/rand"
        "runtime"
        "time"
)

// CollectMetrics collects various metrics to given storage
func CollectMetrics(s Storage, collectInterval time.Duration) error <span class="cov8" title="1">{
        slog.Info("Collecting metrics")
        s.UpdateCounter("PollCount", s.GetCounter("PollCount")+1)
        s.UpdateGauge("RandomValue", rand.Float64())

        ms := runtime.MemStats{}
        runtime.ReadMemStats(&amp;ms)

        s.UpdateGauge("Alloc", float64(ms.Alloc))
        s.UpdateGauge("BuckHashSys", float64(ms.BuckHashSys))
        s.UpdateGauge("Frees", float64(ms.Frees))
        s.UpdateGauge("GCCPUFraction", ms.GCCPUFraction)
        s.UpdateGauge("GCSys", float64(ms.GCSys))
        s.UpdateGauge("HeapAlloc", float64(ms.HeapAlloc))
        s.UpdateGauge("HeapIdle", float64(ms.HeapIdle))
        s.UpdateGauge("HeapInuse", float64(ms.HeapInuse))
        s.UpdateGauge("HeapObjects", float64(ms.HeapObjects))
        s.UpdateGauge("HeapReleased", float64(ms.HeapReleased))
        s.UpdateGauge("HeapSys", float64(ms.HeapSys))
        s.UpdateGauge("LastGC", float64(ms.LastGC))
        s.UpdateGauge("Lookups", float64(ms.Lookups))
        s.UpdateGauge("MCacheInuse", float64(ms.MCacheInuse))
        s.UpdateGauge("MCacheSys", float64(ms.MCacheSys))
        s.UpdateGauge("MSpanInuse", float64(ms.MSpanInuse))
        s.UpdateGauge("MSpanSys", float64(ms.MSpanSys))
        s.UpdateGauge("Mallocs", float64(ms.Mallocs))
        s.UpdateGauge("NextGC", float64(ms.NextGC))
        s.UpdateGauge("NumForcedGC", float64(ms.NumForcedGC))
        s.UpdateGauge("NumGC", float64(ms.NumGC))
        s.UpdateGauge("OtherSys", float64(ms.OtherSys))
        s.UpdateGauge("PauseTotalNs", float64(ms.PauseTotalNs))
        s.UpdateGauge("StackInuse", float64(ms.StackInuse))
        s.UpdateGauge("StackSys", float64(ms.StackSys))
        s.UpdateGauge("Sys", float64(ms.Sys))
        s.UpdateGauge("TotalAlloc", float64(ms.TotalAlloc))
        return nil
}</span>

/*
// Can use smth. like this when all counters are in same object
//    p := Point{3, 5, "Z"}
//    pX := getAttr(&amp;p, "X")
//
//    // Get test (int)
//    fmt.Println(pX.Int()) // 3

func getAttr(obj interface{}, fieldName string) reflect.Value {
    pointToStruct := reflect.ValueOf(obj) // addressable
    curStruct := pointToStruct.Elem()
    if curStruct.Kind() != reflect.Struct {
        panic("not struct")
    }
    curField := curStruct.FieldByName(fieldName) // type: reflect.Value
    if !curField.IsValid() {
        panic("not found:" + fieldName)
    }
    return curField
}
*/
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "context"
        "log/slog"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
)

type mockPoster struct {
        Attempts int
        Cancel   context.CancelFunc
        Results  []error
}

func (p *mockPoster) Post(ctx context.Context, idlog *slog.Logger, metrics []*apimodels.Metrics) (err error) <span class="cov8" title="1">{
        i := len(p.Results) - p.Attempts

        if i &gt;= 0 &amp;&amp; i &lt; len(p.Results) </span><span class="cov8" title="1">{
                err = p.Results[i]
        }</span>
        <span class="cov8" title="1">p.Attempts--
        if (p.Attempts) &lt;= 0 </span><span class="cov8" title="1">{
                p.Cancel()
        }</span>
        <span class="cov8" title="1">return err</span>
}

func NewMockPoster(attempts int, cancel context.CancelFunc, results []error) *mockPoster <span class="cov8" title="1">{
        return &amp;mockPoster{Attempts: attempts, Cancel: cancel, Results: results}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "bytes"
        "compress/gzip"
        "context"
        "crypto/rsa"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/rsacrypt"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/cryptofacade"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/localip"
)

const URLTemplate = "http://%s/updates/"

type netHTTPPoster struct {
        address       string
        key           string
        encryptionKey *rsa.PublicKey
}

func (p *netHTTPPoster) Post(ctx context.Context, idlog *slog.Logger, metrics []*apimodels.Metrics) error <span class="cov8" title="1">{
        body, err := compressMetrics(metrics, p.encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                idlog.Error("failed to prepare request body", "error", err)
                return err
        }</span>

        <span class="cov8" title="1">request, err := http.NewRequestWithContext(ctx, http.MethodPost, p.address, body)
        if err != nil </span><span class="cov0" title="0">{
                idlog.Error("init request error", "error", err)
                return fmt.Errorf("sending metrics: %w", err)
        }</span>

        <span class="cov8" title="1">request.Header.Set("Content-Type", "application/json")
        request.Header.Set("Content-Encoding", "gzip")
        request.Header.Set("Accept-Encoding", "gzip")
        request.Header.Set(constants.HeaderRealIP, localip.GetLocalIP().String())

        if p.key != "" </span><span class="cov8" title="1">{
                hash := cryptofacade.Hash(body.Bytes(), []byte(p.key))
                request.Header.Set(constants.HeaderHashSHA256, hash)
        }</span>

        <span class="cov8" title="1">resp, err := http.DefaultClient.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                idlog.Error("send request error", "error", err)
                return fmt.Errorf("sending metrics: %w", err)
        }</span>

        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.Body != nil </span><span class="cov8" title="1">{
                defer resp.Body.Close()
        }</span>

        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                idlog.Error("response error", "error", resp.StatusCode)
                return fmt.Errorf("sending metrics https status error: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// compressMetrics compresses the metrics using gzip.
func compressMetrics(metricUpdates []*apimodels.Metrics, encryptionKey *rsa.PublicKey) (*bytes.Buffer, error) <span class="cov8" title="1">{
        content, err := json.Marshal(metricUpdates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(fmt.Errorf("encoding request: %w", err), ErrTransport)
        }</span>
        <span class="cov8" title="1">body := new(bytes.Buffer)
        zb := gzip.NewWriter(body)
        defer zb.Close()
        if encryptionKey != nil </span><span class="cov8" title="1">{
                content, err = rsacrypt.EncryptWithPublicKey(content, encryptionKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("encrypting request: %w", err)
                }</span>
        }
        <span class="cov8" title="1">_, err = zb.Write(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("compressing request: %w", err)
        }</span>

        <span class="cov8" title="1">return body, nil</span>
}

func NewNetHTTPPoster(address string, key string, encryptionKey *rsa.PublicKey) *netHTTPPoster <span class="cov8" title="1">{
        address = fmt.Sprintf(URLTemplate, address)
        return &amp;netHTTPPoster{
                address:       address,
                key:           key,
                encryptionKey: encryptionKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "context"
        "crypto/rsa"
        "fmt"
        "log/slog"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/cryptofacade"
        "github.com/go-resty/resty/v2"
)

type restyPoster struct {
        netHTTPPoster
}

func (p *restyPoster) Post(ctx context.Context, idlog *slog.Logger, metrics []*apimodels.Metrics) error <span class="cov8" title="1">{
        body, err := compressMetrics(metrics, p.encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                idlog.Error("failed to prepare request body", "error", err)
                return err
        }</span>

        <span class="cov8" title="1">client := resty.New()
        req := client.R()
        req.SetContext(ctx)
        req.SetHeader("Content-Encoding", "gzip")
        req.SetHeader("Accept-Encoding", "gzip")
        req.SetHeader("Content-Type", "application/json")

        if p.key != "" </span><span class="cov8" title="1">{
                hash := cryptofacade.Hash(body.Bytes(), []byte(p.key))
                req.SetHeader(constants.HeaderHashSHA256, hash)
        }</span>

        <span class="cov8" title="1">req.SetBody(body)
        resp, err := req.Post(p.address)
        if err != nil </span><span class="cov0" title="0">{
                idlog.Error("send request error", "error", err)
                return fmt.Errorf("sending metrics: %w", err)
        }</span>

        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.RawResponse.Body != nil </span><span class="cov8" title="1">{
                _ = resp.RawResponse.Body.Close()
        }</span>

        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.IsError() </span><span class="cov0" title="0">{
                idlog.Error("response error", "error", resp.Error())
                return fmt.Errorf("sending metrics https status error: %d", resp.StatusCode())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func NewRestyPoster(address string, key string, encryptionKey *rsa.PublicKey) *restyPoster <span class="cov8" title="1">{
        return &amp;restyPoster{*NewNetHTTPPoster(address, key, encryptionKey)}
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "context"
        "errors"
        "log/slog"
        "net"
        "sync"
        "time"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers"

        "golang.org/x/sync/errgroup"
)

type Retryer interface {
        Try(ctx context.Context, do func() error, isRetryable func(err error) bool) (int, error)
}

type MetricsPoster interface {
        Post(ctx context.Context, idlog *slog.Logger, metrics []*apimodels.Metrics) error
}

var ErrTransport = errors.New("resty error")

// SendMetrics sends pre collected metrics to server
func SendMetrics(ctx context.Context, s Storage, r Retryer, poster MetricsPoster, rateLimit int) <span class="cov8" title="1">{
        slog.Info("Sending metricUpdates")

        w := newWorker(poster)
        p := newProducer(ctx, s, w, rateLimit)
        if _, err := r.Try(ctx, p, isRecoverable); err != nil </span><span class="cov8" title="1">{
                slog.Info("SendMetrics error", "error", err)
        }</span>
}

func isRecoverable(err error) bool <span class="cov8" title="1">{
        var netErr net.Error
        if errors.As(err, &amp;netErr) &amp;&amp; netErr != nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

type workerFunc = func(ctx context.Context, id int, mCh &lt;-chan *apimodels.Metrics) error

func newWorker(poster MetricsPoster) workerFunc <span class="cov8" title="1">{
        return func(ctx context.Context, id int, mCh &lt;-chan *apimodels.Metrics) error </span><span class="cov8" title="1">{
                idlog := slog.With("workerFunc", "metricUpdates", "id", id)
                metricUpdates := make([]*apimodels.Metrics, 0)
                for m := range mCh </span><span class="cov8" title="1">{
                        metricUpdates = append(metricUpdates, m)
                }</span>

                <span class="cov8" title="1">idlog.Info("received metricUpdates", "count", len(metricUpdates))
                if len(metricUpdates) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">return poster.Post(ctx, idlog, metricUpdates)</span>
        }
}

func newProducer(ctx context.Context, s Storage, w workerFunc, l int) func() error <span class="cov8" title="1">{
        return func() error </span><span class="cov8" title="1">{
                ch := make(chan *apimodels.Metrics)
                eg, innerCtx := errgroup.WithContext(ctx)
                for i := 0; i &lt; l; i++ </span><span class="cov8" title="1">{
                        eg.Go(func() error </span><span class="cov8" title="1">{ return w(innerCtx, i, ch) }</span>)
                }

                <span class="cov8" title="1">for _, counterName := range s.ListCounters() </span><span class="cov8" title="1">{
                        counter := int64(s.GetCounter(counterName))
                        ch &lt;- &amp;apimodels.Metrics{
                                ID:    counterName,
                                MType: constants.CounterStr,
                                Delta: &amp;counter,
                                Value: nil,
                        }
                }</span>
                <span class="cov8" title="1">for _, gaugeName := range s.ListGauges() </span><span class="cov8" title="1">{
                        gauge := s.GetGauge(gaugeName)
                        ch &lt;- &amp;apimodels.Metrics{
                                ID:    gaugeName,
                                MType: constants.GaugeStr,
                                Delta: nil,
                                Value: &amp;gauge,
                        }
                }</span>

                <span class="cov8" title="1">close(ch)
                return eg.Wait()</span>
        }
}

func SendMetricsLoop(
        ctx context.Context,
        wg *sync.WaitGroup,
        storage Storage,
        sendInterval time.Duration,
        retryer handlers.Retryer,
        poster MetricsPoster,
        rateLimit int,
) <span class="cov8" title="1">{
        cb := func() </span><span class="cov8" title="1">{
                SendMetrics(ctx, storage, retryer, poster, rateLimit)
                slog.Info(`sender sleeping`, `delay`, sendInterval)
        }</span>
        <span class="cov8" title="1">loop(cb, ctx, wg, sendInterval)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package configfile - config file package
package configfile

import (
        "encoding/json"
        "os"

        flag "github.com/spf13/pflag"
)

const (
        configEnv      = "CONFIG"
        configFlag     = "c"
        configFlagFull = "config"
)

func ParseFile(config any) <span class="cov8" title="1">{
        fn := getConfigFileName()
        if fn == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">data, _ := os.ReadFile(fn)
        json.Unmarshal(data, &amp;config)</span>
}

func getConfigFileName() (f string) <span class="cov8" title="1">{
        f = os.Getenv(configEnv)
        if f != "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">cl := flag.NewFlagSet(configFlagFull, flag.ContinueOnError)
        cl.StringVarP(&amp;f, configFlagFull, configFlag, f, "")
        cl.Parse(os.Args[1:])
        return</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cryptofacade

import (
        "crypto/sha256"
        "encoding/hex"
)

func Hash(body, key []byte) string <span class="cov8" title="1">{
        // создаём новый hash.Hash, вычисляющий контрольную сумму SHA-256
        h := sha256.New()
        // передаём байты для хеширования
        h.Write(body)
        // получаем хеш в виде строки
        return hex.EncodeToString(h.Sum(key))
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package jsonofflinestorage

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "log/slog"
        "os"
        "sync"
        "time"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
)

type Storage interface {
        GetCounter(key string) (int, error)
        GetGauge(key string) (float64, error)
        ListGauges() ([]string, error)
        ListCounters() ([]string, error)
        SaveCommonModel(metric *apimodels.Metrics) error
}

// JSONFileStorage is a background routine to manage json data file.
type JSONFileStorage struct {
        storage          Storage
        fileName         string
        isRestoreEnabled bool
        storeInterval    time.Duration
        mu               *sync.Mutex
        saved            chan struct{}
        clear            func() bool
}

func NewJSONFileStorage(storage Storage, fileName string, restore bool, storeInterval int, saved chan struct{}, clear func() bool) *JSONFileStorage <span class="cov0" title="0">{
        return &amp;JSONFileStorage{
                storage:          storage,
                fileName:         fileName,
                isRestoreEnabled: restore,
                storeInterval:    time.Duration(storeInterval) * time.Second,
                mu:               new(sync.Mutex),
                saved:            saved,
                clear:            clear,
        }
}</span>

func (l *JSONFileStorage) Start(ctx context.Context, wg *sync.WaitGroup) error <span class="cov0" title="0">{
        if err := l.restore(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not isRestoreEnabled json file: %w", err)
        }</span>
        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                err := l.saveToFile(ctx, wg)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("async saver failed", "error", err)
                }</span>
        }()
        <span class="cov0" title="0">return nil</span>
}

func (l *JSONFileStorage) save() error <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // check if we can live without it.
        if !l.clear() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(l.fileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't open file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)

        list, err := l.storage.ListGauges()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't ListGauges: %w", err)
        }</span>
        <span class="cov0" title="0">for _, key := range list </span><span class="cov0" title="0">{
                g, errStupidLinter := l.storage.GetGauge(key)
                if errStupidLinter != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't GetGauge: %w", errStupidLinter)
                }</span>
                <span class="cov0" title="0">err = encoder.Encode(apimodels.Metrics{
                        ID:    key,
                        MType: constants.GaugeStr,
                        Delta: nil,
                        Value: &amp;g,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't write JSON: %w", err)
                }</span>
        }

        <span class="cov0" title="0">list, err = l.storage.ListCounters()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't ListCounters: %w", err)
        }</span>
        <span class="cov0" title="0">for _, key := range list </span><span class="cov0" title="0">{
                c, errStupidLinter := l.storage.GetCounter(key)
                if errStupidLinter != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't GetCounter: %w", errStupidLinter)
                }</span>
                <span class="cov0" title="0">c64 := int64(c)
                err = encoder.Encode(apimodels.Metrics{
                        ID:    key,
                        MType: constants.CounterStr,
                        Delta: &amp;c64,
                        Value: nil,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't write JSON: %w", err)
                }</span>
        }

        <span class="cov0" title="0">slog.Info("Saved to file", "file", l.fileName, "error", err)
        return nil</span>
}

func (l *JSONFileStorage) restore() error <span class="cov0" title="0">{
        if !l.isRestoreEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">file, err := os.OpenFile(l.fileName, os.O_RDONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, fs.ErrNotExist) </span><span class="cov0" title="0">{
                        slog.Warn("file does not exist, skipping JSON load", "error", err, "filename", l.fileName)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("can't open file: %w", err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        decoder := json.NewDecoder(file)

        for </span><span class="cov0" title="0">{
                v := &amp;apimodels.Metrics{}
                if err = decoder.Decode(v); errors.Is(err, io.ErrUnexpectedEOF) || errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        // just done.
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't decode json: %w", err)
                }</span>

                <span class="cov0" title="0">if err = l.storage.SaveCommonModel(v); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't save value: %w", err)
                }</span>
        }

        <span class="cov0" title="0">slog.Info("Restored from file", "file", l.fileName)
        return nil</span>
}

type SavedChan = chan struct{}

func (l *JSONFileStorage) saveToFile(ctx context.Context, wg *sync.WaitGroup) error <span class="cov0" title="0">{
        defer wg.Done()
        do := true
        if l.storeInterval &gt; 0 </span><span class="cov0" title="0">{
                t := time.NewTimer(l.storeInterval)
                defer t.Stop()
                for do </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                do = false</span>
                        case &lt;-t.C:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">if err := l.save(); err != nil </span><span class="cov0" title="0">{
                                slog.Error("saveToFile error", "error", err)
                        }</span>

                        <span class="cov0" title="0">if do </span><span class="cov0" title="0">{
                                t.Reset(l.storeInterval)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">for do </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        do = false</span>
                case &lt;-l.saved:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if err := l.save(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("saveToFile error", "error", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package localip

import (
        "net"
)

func GetLocalIP() (r net.IP) <span class="cov8" title="1">{
        conn, err := net.Dial("udp", "8.8.8.8:80")
        r = net.IP{}

        if err == nil </span><span class="cov8" title="1">{
                defer conn.Close()
                localAddress := conn.LocalAddr().(*net.UDPAddr)
                r = localAddress.IP
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package metricstorage

import (
        "context"
        "database/sql"
        "errors"

        "github.com/jackc/pgx/v5"
        _ "github.com/jackc/pgx/v5/stdlib"
)

// DBStorage store metrics in DB
// TODO: use context and handle errors in all methods.
type DBStorage struct {
        db *sql.DB
}

type DBBatch struct {
        tx *sql.Tx
}

type execSQL func(query string, args ...any) (sql.Result, error)

func NewDBStorage(db *sql.DB, ctx context.Context) (s *DBStorage, err error) <span class="cov0" title="0">{
        s = &amp;DBStorage{
                db: db,
        }

        // IRL it should be done in main() with separate command line flag.
        if err = s.Bootstrap(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

// Bootstrap подготавливает БД к работе, создавая необходимые таблицы и индексы
func (s *DBStorage) Bootstrap(ctx context.Context) error <span class="cov0" title="0">{
        // запускаем транзакцию
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // в случае неуспешного коммита все изменения транзакции будут отменены
        // если вместо _ = tx.Rollback() в каждом условии здесь вызвать defer tx.Rollback()

        // создаём таблицу целочисленных счетчиков и необходимый индекс
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, `
                CREATE TABLE IF NOT EXISTS gauge (
                        name varchar(250) NOT NULL,
                        value double PRECISION NOT NULL
                )
    `)
        if err != nil </span><span class="cov0" title="0">{
                _ = tx.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, `CREATE UNIQUE INDEX IF NOT EXISTS gauge_name_udx ON gauge (name)`)
        if err != nil </span><span class="cov0" title="0">{
                _ = tx.Rollback()
                return err
        }</span>

        // создаём таблицу дробных счетчиков и необходимый индекс
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, `
                CREATE TABLE IF NOT EXISTS counter (
                        name varchar(250) NOT NULL,
                        value bigint NOT NULL
                )
    `)
        if err != nil </span><span class="cov0" title="0">{
                _ = tx.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, `CREATE UNIQUE INDEX IF NOT EXISTS counter_name_udx ON counter (name)`)
        if err != nil </span><span class="cov0" title="0">{
                _ = tx.Rollback()
                return err
        }</span>

        // коммитим транзакцию
        <span class="cov0" title="0">return tx.Commit()</span>
}

func updateCounterSQL(exec execSQL, key string, value int) error <span class="cov0" title="0">{
        _, err := exec(`
        INSERT INTO counter (name, value)
                VALUES (@name, @value)
                ON CONFLICT (name) DO UPDATE SET value = counter.value+EXCLUDED.value;
    `, pgx.NamedArgs{"name": key, "value": value})
        return err

}</span>

func (s *DBStorage) UpdateCounter(key string, value int) error <span class="cov0" title="0">{
        return updateCounterSQL(s.db.Exec, key, value)
}</span>

func updateGaugeSQL(exec execSQL, key string, value float64) error <span class="cov0" title="0">{
        _, err := exec(`
        INSERT INTO gauge (name, value)
                VALUES (@name, @value)
                ON CONFLICT (name) DO UPDATE SET value = EXCLUDED.value;
    `, pgx.NamedArgs{"name": key, "value": value})
        return err
}</span>
func (s *DBStorage) UpdateGauge(key string, value float64) error <span class="cov0" title="0">{
        return updateGaugeSQL(s.db.Exec, key, value)
}</span>

func (s *DBStorage) GetCounter(key string) (r int, err error) <span class="cov0" title="0">{
        row := s.db.QueryRow(`
        SELECT t.value FROM counter t WHERE t.name = @name
    `, pgx.NamedArgs{"name": key})
        err = row.Scan(&amp;r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return r, err</span>
}

func (s *DBStorage) GetGauge(key string) (r float64, err error) <span class="cov0" title="0">{
        row := s.db.QueryRow(`
        SELECT t.value FROM gauge t WHERE t.name = @name
    `, pgx.NamedArgs{"name": key})
        err = row.Scan(&amp;r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return r, err</span>
}

func (s *DBStorage) HasCounter(key string) (r bool, err error) <span class="cov0" title="0">{
        row := s.db.QueryRow(`
        SELECT EXISTS(SELECT 1 FROM counter t WHERE t.name = @name)
    `, pgx.NamedArgs{"name": key})
        err = row.Scan(&amp;r)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return r, err</span>
}

func (s *DBStorage) HasGauge(key string) (r bool, err error) <span class="cov0" title="0">{
        row := s.db.QueryRow(`
        SELECT EXISTS(SELECT 1 FROM gauge t WHERE t.name = @name)
    `, pgx.NamedArgs{"name": key})
        err = row.Scan(&amp;r)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return r, err</span>
}

func (s *DBStorage) ListGauges() ([]string, error) <span class="cov0" title="0">{
        keys := []string{}
        rows, err := s.db.Query(`
        SELECT t.name FROM gauge t
    `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var k string
                if err = rows.Scan(&amp;k); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">keys = append(keys, k)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return keys, nil</span>
}

func (s *DBStorage) ListCounters() ([]string, error) <span class="cov0" title="0">{
        keys := []string{}
        rows, err := s.db.Query(`
        SELECT t.name FROM counter t
    `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var k string
                if err = rows.Scan(&amp;k); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">keys = append(keys, k)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return keys, nil</span>
}

func (s *DBStorage) StartBatch(ctx context.Context) (basicBatch, error) <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;DBBatch{tx: tx}, nil</span>
}

func (b *DBBatch) UpdateCounter(key string, value int) error <span class="cov0" title="0">{
        err := updateCounterSQL(b.tx.Exec, key, value)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Join(err, b.rollback())
        }</span>
        <span class="cov0" title="0">return err</span>
}
func (b *DBBatch) UpdateGauge(key string, value float64) error <span class="cov0" title="0">{
        err := updateGaugeSQL(b.tx.Exec, key, value)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Join(err, b.rollback())
        }</span>
        <span class="cov0" title="0">return err</span>
}
func (b *DBBatch) Commit() error <span class="cov0" title="0">{
        return b.tx.Commit()
}</span>
func (b *DBBatch) rollback() error <span class="cov0" title="0">{
        return b.tx.Commit()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package metricstorage

import "sync"

type DirtyStorage struct {
        basicStorage
        SavedChan chan struct{}
        isDirty   bool
        dirtyMx   *sync.Mutex
}

// NewDirtyStorage creates new storage
func NewDirtyStorage(storage basicStorage) *DirtyStorage <span class="cov8" title="1">{
        return &amp;DirtyStorage{
                basicStorage: storage,
                isDirty:      false,
                SavedChan:    make(chan struct{}),
                dirtyMx:      &amp;sync.Mutex{},
        }
}</span>

func (ds *DirtyStorage) UpdateCounter(key string, value int) error <span class="cov8" title="1">{
        err := ds.basicStorage.UpdateCounter(key, value)
        if err == nil </span><span class="cov8" title="1">{
                ds.markDirty()
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (ds *DirtyStorage) UpdateGauge(key string, value float64) error <span class="cov8" title="1">{
        err := ds.basicStorage.UpdateGauge(key, value)
        if err == nil </span><span class="cov8" title="1">{
                ds.markDirty()
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (ds *DirtyStorage) markDirty() <span class="cov8" title="1">{
        ds.dirtyMx.Lock()
        defer ds.dirtyMx.Unlock()
        ds.isDirty = true
        select </span>{
        case ds.SavedChan &lt;- struct{}{}:<span class="cov0" title="0"></span>
        default:<span class="cov8" title="1"></span>
        }
}

// Clear removes dirty flag and returns its current value.
func (ds *DirtyStorage) Clear() bool <span class="cov8" title="1">{
        ds.dirtyMx.Lock()
        defer ds.dirtyMx.Unlock()
        result := ds.isDirty
        ds.isDirty = false
        return result
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package metricstorage

import (
        "context"
        "sync"
)

type MemStorage struct {
        counters    map[string]int
        countersRWM *sync.RWMutex
        gauges      map[string]float64
        gaugesRWM   *sync.RWMutex
        inBatch     bool
}

type MemBatch struct {
        ms *MemStorage
}

func NewMemStorage() *MemStorage <span class="cov8" title="1">{
        return &amp;MemStorage{
                counters:    make(map[string]int),
                countersRWM: new(sync.RWMutex),
                gauges:      make(map[string]float64),
                gaugesRWM:   new(sync.RWMutex),
        }
}</span>

func (s *MemStorage) UpdateCounter(key string, value int) error <span class="cov8" title="1">{
        if !s.inBatch </span><span class="cov8" title="1">{
                s.countersRWM.Lock()
                defer s.countersRWM.Unlock()
        }</span>
        <span class="cov8" title="1">s.counters[key] += value
        return nil</span>
}

func (s *MemStorage) UpdateGauge(key string, value float64) error <span class="cov8" title="1">{
        if !s.inBatch </span><span class="cov8" title="1">{
                s.gaugesRWM.Lock()
                defer s.gaugesRWM.Unlock()
        }</span>
        <span class="cov8" title="1">s.gauges[key] = value
        return nil</span>
}

func (s *MemStorage) GetCounter(key string) (int, error) <span class="cov8" title="1">{
        s.countersRWM.RLock()
        defer s.countersRWM.RUnlock()
        return s.counters[key], nil
}</span>

func (s *MemStorage) GetGauge(key string) (float64, error) <span class="cov8" title="1">{
        s.gaugesRWM.RLock()
        defer s.gaugesRWM.RUnlock()
        return s.gauges[key], nil
}</span>

func (s *MemStorage) HasCounter(key string) (bool, error) <span class="cov8" title="1">{
        s.countersRWM.RLock()
        defer s.countersRWM.RUnlock()
        _, ok := s.counters[key]
        return ok, nil
}</span>

func (s *MemStorage) HasGauge(key string) (bool, error) <span class="cov8" title="1">{
        s.gaugesRWM.RLock()
        defer s.gaugesRWM.RUnlock()
        _, ok := s.gauges[key]
        return ok, nil
}</span>

// ListGauges lists all gauges keys.
func (s *MemStorage) ListGauges() ([]string, error) <span class="cov8" title="1">{
        s.gaugesRWM.RLock()
        defer s.gaugesRWM.RUnlock()
        keys := make([]string, 0, len(s.gauges))
        for k := range s.gauges </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys, nil</span>
}

// ListCounters lists all counters keys.
func (s *MemStorage) ListCounters() ([]string, error) <span class="cov8" title="1">{
        s.countersRWM.RLock()
        defer s.countersRWM.RUnlock()
        keys := make([]string, 0, len(s.counters))
        for k := range s.counters </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys, nil</span>
}

func (s *MemStorage) StartBatch(ctx context.Context) (basicBatch, error) <span class="cov8" title="1">{
        s.countersRWM.Lock()
        s.gaugesRWM.Lock()
        s.inBatch = true
        return &amp;MemBatch{ms: s}, nil
}</span>

func (b *MemBatch) UpdateCounter(key string, value int) error <span class="cov8" title="1">{
        return b.ms.UpdateCounter(key, value)
}</span>
func (b *MemBatch) UpdateGauge(key string, value float64) error <span class="cov8" title="1">{
        return b.ms.UpdateGauge(key, value)

}</span>
func (b *MemBatch) Commit() error <span class="cov8" title="1">{
        b.ms.inBatch = false
        b.ms.countersRWM.Unlock()
        b.ms.gaugesRWM.Unlock()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package metricstorage

type MemStorageMuted struct {
        MemStorage
}

func NewMemStorageMuted() *MemStorageMuted <span class="cov8" title="1">{
        return &amp;MemStorageMuted{
                MemStorage: *NewMemStorage(),
        }
}</span>

func (s *MemStorageMuted) UpdateCounter(key string, value int) <span class="cov8" title="1">{
        _ = s.MemStorage.UpdateCounter(key, value)
}</span>

func (s *MemStorageMuted) UpdateGauge(key string, value float64) <span class="cov8" title="1">{
        _ = s.MemStorage.UpdateGauge(key, value)
}</span>

func (s *MemStorageMuted) GetCounter(key string) int <span class="cov8" title="1">{
        r, _ := s.MemStorage.GetCounter(key)
        return r
}</span>

func (s *MemStorageMuted) GetGauge(key string) float64 <span class="cov8" title="1">{
        r, _ := s.MemStorage.GetGauge(key)
        return r
}</span>

func (s *MemStorageMuted) ListGauges() []string <span class="cov8" title="1">{
        keys, _ := s.MemStorage.ListGauges()
        return keys
}</span>

func (s *MemStorageMuted) ListCounters() []string <span class="cov8" title="1">{
        keys, _ := s.MemStorage.ListCounters()
        return keys
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package metricstorage

import (
        "io"
)

type MockErrorStorage struct {
        MemStorage
        WithError bool
}

func (s *MockErrorStorage) HasCounter(key string) (bool, error) <span class="cov8" title="1">{
        if s.WithError </span><span class="cov8" title="1">{
                return false, io.EOF
        }</span>
        <span class="cov8" title="1">return s.MemStorage.HasCounter(key)</span>
}

func (s *MockErrorStorage) HasGauge(key string) (bool, error) <span class="cov8" title="1">{
        if s.WithError </span><span class="cov8" title="1">{
                return false, io.EOF
        }</span>
        <span class="cov8" title="1">return s.MemStorage.HasGauge(key)</span>
}

func (s *MockErrorStorage) UpdateCounter(key string, value int) error <span class="cov8" title="1">{
        if s.WithError </span><span class="cov8" title="1">{
                return io.EOF
        }</span>
        <span class="cov8" title="1">return s.MemStorage.UpdateCounter(key, value)</span>
}

func (s *MockErrorStorage) UpdateGauge(key string, value float64) error <span class="cov8" title="1">{
        if s.WithError </span><span class="cov8" title="1">{
                return io.EOF
        }</span>
        <span class="cov8" title="1">return s.MemStorage.UpdateGauge(key, value)</span>
}

func (s *MockErrorStorage) GetCounter(key string) (int, error) <span class="cov8" title="1">{
        if s.WithError </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">return s.MemStorage.GetCounter(key)</span>
}

func (s *MockErrorStorage) GetGauge(key string) (float64, error) <span class="cov8" title="1">{
        if s.WithError </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">return s.MemStorage.GetGauge(key)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Main storage wrapper for the server application
package metricstorage

import (
        "context"
        "errors"
        "fmt"
        "html"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
)

type basicBatch interface {
        basicUpdater
        Commit() error
}

type basicStorage interface {
        UpdateCounter(key string, value int) error
        UpdateGauge(key string, value float64) error
        GetCounter(key string) (int, error)
        GetGauge(key string) (float64, error)
        HasCounter(key string) (bool, error)
        HasGauge(key string) (bool, error)
        ListGauges() ([]string, error)
        ListCounters() ([]string, error)
        StartBatch(ctx context.Context) (basicBatch, error)
}

// SavableModelStorage wrapper around storage interface
type SavableModelStorage struct {
        basicStorage
}

func NewSavableModelStorage(bs basicStorage) *SavableModelStorage <span class="cov8" title="1">{
        return &amp;SavableModelStorage{
                basicStorage: bs,
        }
}</span>

type basicUpdater interface {
        UpdateCounter(key string, value int) error
        UpdateGauge(key string, value float64) error
}

// saveCommonModel — common function for saving models
func saveCommonModel(u basicUpdater, metric *apimodels.Metrics) (err error) <span class="cov8" title="1">{
        switch metric.MType </span>{
        case constants.GaugeStr:<span class="cov8" title="1">
                if metric.Value == nil </span><span class="cov8" title="1">{
                        return errors.New("empty metric value, float64 required")
                }</span>
                <span class="cov8" title="1">err = u.UpdateGauge(metric.ID, *metric.Value)</span>
        case constants.CounterStr:<span class="cov8" title="1">
                if metric.Delta == nil </span><span class="cov8" title="1">{
                        return errors.New("empty metric delta, integer required")
                }</span>
                <span class="cov8" title="1">delta := int(*metric.Delta)
                err = u.UpdateCounter(metric.ID, delta)</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf(
                        "invalid type \"%s\", only %s and %s supported",
                        html.EscapeString(metric.MType),
                        constants.GaugeStr,
                        constants.CounterStr,
                )</span>
        }

        <span class="cov8" title="1">return err</span>
}

// SaveCommonModel save standard model or throw error
func (s *SavableModelStorage) SaveCommonModel(metric *apimodels.Metrics) (err error) <span class="cov8" title="1">{
        return saveCommonModel(s, metric)
}</span>

// SaveCommonModels save slice of standard models or throw error
func (s *SavableModelStorage) SaveCommonModels(ctx context.Context, metrics []apimodels.Metrics) error <span class="cov8" title="1">{
        batch, err := s.StartBatch(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, m := range metrics </span><span class="cov8" title="1">{
                if err = saveCommonModel(batch, &amp;m); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = batch.Commit()

        return err</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mockreaders

import (
        "bytes"
        "io"
)

// ErrCloser — специальная структура, эмулирующая ошибку закрытия
type ErrCloser struct {
        *bytes.Buffer
}

func NewErrCloser(buf []byte) *ErrCloser <span class="cov8" title="1">{
        return &amp;ErrCloser{bytes.NewBuffer(buf)}
}</span>
func (e *ErrCloser) Close() error <span class="cov8" title="1">{
        return io.ErrClosedPipe
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package mockreaders

import (
        "errors"
)

// ErrReader — специальная структура, эмулирующая ошибку чтения
type ErrReader struct{}

func (e *ErrReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return 0, errors.New("эмулированная ошибка чтения")
}</span>

func (e *ErrReader) Close() error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package printbuild - Print Build
package printbuild

import (
        "os"
        "text/template"
)

type Data struct {
        BuildVersion string
        BuildDate    string
        BuildCommit  string
}

const Template = `Build version: {{ if .BuildVersion }}{{ .BuildVersion }}{{ else }}N/A{{ end }}
Build date: {{ if .BuildDate }}{{ .BuildDate }}{{ else }}N/A{{ end }}
Build commit: {{ if .BuildCommit }}{{ .BuildCommit }}{{ else }}N/A{{ end }} 
`

func (d *Data) Print() <span class="cov8" title="1">{
        t := template.Must(template.New("-").Parse(Template))

        _ = t.Execute(os.Stdout, d)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package retryattempt

import (
        "context"
        "errors"
        "fmt"
        "time"
)

type Retryer struct {
        delays []time.Duration
}

func NewRetryer(delays []time.Duration) *Retryer <span class="cov8" title="1">{
        return &amp;Retryer{delays: delays}
}</span>

func NewOneAttemptRetryer() *Retryer <span class="cov8" title="1">{
        return NewRetryer([]time.Duration{})
}</span>

// Try Attempts retryable operation. Returns retry attempts count always and error on fail.
func (r *Retryer) Try(ctx context.Context, do func() error, isRetryable func(err error) bool) (r1 int, r2 error) <span class="cov8" title="1">{
        tmr := time.NewTimer(0)
        defer tmr.Stop()
out:
        for i := 0; i &lt;= len(r.delays); i++ </span><span class="cov8" title="1">{
                if err := do(); err != nil </span><span class="cov8" title="1">{
                        if !isRetryable(err) </span><span class="cov8" title="1">{
                                r1 = i + 1
                                r2 = fmt.Errorf("(retry) attempt #%d was not recoverable: %w", i+1, err)
                                break</span>
                        }

                        <span class="cov8" title="1">if i == len(r.delays) </span><span class="cov8" title="1">{
                                r1 = i + 1
                                r2 = fmt.Errorf("(retry) attempt #%d all attempts made, last error: %w", i+1, err)
                                break</span>
                        }

                        <span class="cov8" title="1">delay := r.delays[i]

                        tmr.Stop()
                        tmr.Reset(delay)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                r1 = i + 1
                                r2 = errors.Join(fmt.Errorf("(retry) attempt #%d context exceeded after error: %w", i+1, err), context.DeadlineExceeded)
                                break out</span>
                        case &lt;-tmr.C:<span class="cov8" title="1">
                                continue</span>
                        }
                }

                <span class="cov8" title="1">r1 = i + 1
                r2 = nil
                break</span>
        }

        <span class="cov8" title="1">return r1, r2</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package rsacrypt RSA crypt from https://gist.github.com/miguelmota/3ea9286bd1d3c2a985b67cac4ba2130a
package rsacrypt

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha512"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "hash"
        "io"
        "os"
)

// GenerateKeyPair generates a new key pair
func GenerateKeyPair(bits int) (*rsa.PrivateKey, *rsa.PublicKey) <span class="cov8" title="1">{
        privkey, err := rsa.GenerateKey(rand.Reader, bits)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return privkey, &amp;privkey.PublicKey</span>
}

// PrivateKeyToBytes private key to bytes
func PrivateKeyToBytes(priv *rsa.PrivateKey) []byte <span class="cov8" title="1">{
        privBytes := pem.EncodeToMemory(
                &amp;pem.Block{
                        Type:  "RSA PRIVATE KEY",
                        Bytes: x509.MarshalPKCS1PrivateKey(priv),
                },
        )

        return privBytes
}</span>

// PublicKeyToBytes public key to bytes
func PublicKeyToBytes(pub *rsa.PublicKey) []byte <span class="cov8" title="1">{
        pubASN1, err := x509.MarshalPKIXPublicKey(pub)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">pubBytes := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PUBLIC KEY",
                Bytes: pubASN1,
        })

        return pubBytes</span>
}

// BytesToPrivateKey bytes to private key
func BytesToPrivateKey(priv []byte) (*rsa.PrivateKey, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(priv)
        b := block.Bytes
        return x509.ParsePKCS1PrivateKey(b)
}</span>

// BytesToPublicKey bytes to public key
func BytesToPublicKey(pub []byte) (*rsa.PublicKey, error) <span class="cov8" title="1">{
        block, _ := pem.Decode(pub)
        b := block.Bytes
        var err error
        ifc, err := x509.ParsePKIXPublicKey(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">key, ok := ifc.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("not ok")
        }</span>
        <span class="cov8" title="1">return key, nil</span>
}

func FileToPrivateKey(fileName string) (*rsa.PrivateKey, error) <span class="cov8" title="1">{
        bytes, err := os.ReadFile(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return BytesToPrivateKey(bytes)</span>
}

func FileToPublicKey(fileName string) (*rsa.PublicKey, error) <span class="cov8" title="1">{
        bytes, err := os.ReadFile(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return BytesToPublicKey(bytes)</span>
}

// EncryptWithPublicKey encrypts data with public key
func EncryptWithPublicKey(msg []byte, pub *rsa.PublicKey) ([]byte, error) <span class="cov8" title="1">{
        hash := sha512.New()
        ciphertext, err := EncryptOAEP(hash, rand.Reader, pub, msg, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ciphertext, nil</span>
}

// DecryptWithPrivateKey decrypts data with private key
func DecryptWithPrivateKey(ciphertext []byte, priv *rsa.PrivateKey) ([]byte, error) <span class="cov8" title="1">{
        hash := sha512.New()
        plaintext, err := DecryptOAEP(hash, rand.Reader, priv, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return plaintext, nil</span>
}

// EncryptOAEP works beyound block size
//
// see https://stackoverflow.com/questions/62348923/rs256-message-too-long-for-rsa-public-key-size-error-signing-jwt
func EncryptOAEP(hash hash.Hash, random io.Reader, public *rsa.PublicKey, msg []byte, label []byte) ([]byte, error) <span class="cov8" title="1">{
        msgLen := len(msg)
        step := public.Size() - 2*hash.Size() - 2
        var encryptedBytes []byte

        for start := 0; start &lt; msgLen; start += step </span><span class="cov8" title="1">{
                finish := start + step
                if finish &gt; msgLen </span><span class="cov8" title="1">{
                        finish = msgLen
                }</span>

                <span class="cov8" title="1">encryptedBlockBytes, err := rsa.EncryptOAEP(hash, random, public, msg[start:finish], label)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">encryptedBytes = append(encryptedBytes, encryptedBlockBytes...)</span>
        }

        <span class="cov8" title="1">return encryptedBytes, nil</span>
}

// DecryptOAEP works beyound block size
//
// see https://stackoverflow.com/questions/62348923/rs256-message-too-long-for-rsa-public-key-size-error-signing-jwt
func DecryptOAEP(hash hash.Hash, random io.Reader, private *rsa.PrivateKey, msg []byte, label []byte) ([]byte, error) <span class="cov8" title="1">{
        msgLen := len(msg)
        step := private.PublicKey.Size()
        var decryptedBytes []byte

        for start := 0; start &lt; msgLen; start += step </span><span class="cov8" title="1">{
                finish := start + step
                if finish &gt; msgLen </span><span class="cov0" title="0">{
                        finish = msgLen
                }</span>

                <span class="cov8" title="1">decryptedBlockBytes, err := rsa.DecryptOAEP(hash, random, private, msg[start:finish], label)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">decryptedBytes = append(decryptedBytes, decryptedBlockBytes...)</span>
        }

        <span class="cov8" title="1">return decryptedBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "html"
        "log/slog"
        "net/http"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/gin-gonic/gin"
)

// CheckMetricExistenceHandler checks metrics has value set
// Previous handler should add valid metric to context
func CheckMetricExistenceHandler(s Storage) func(c *gin.Context) <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                metric := &amp;apimodels.Metrics{}

                // IRL just use err := c.BindJSON(&amp;metric); and c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
                // use json and http on our own
                dec := json.NewDecoder(c.Request.Body)
                if err := dec.Decode(metric); err != nil </span><span class="cov8" title="1">{
                        slog.Error("can't parse JSON", "error", err)
                        // TODO: replace with c.AbortWithError to skip later middlewares
                        http.Error(c.Writer, "Invalid JSON", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">switch metric.MType </span>{
                case constants.GaugeStr:<span class="cov8" title="1">
                        if h, err := s.HasGauge(metric.ID); err != nil || !h </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov8" title="1">{
                                        slog.Error("can't check metric existence", "id", metric.ID, "error", err)
                                        http.Error(c.Writer, `unexpected error`, http.StatusInternalServerError)
                                        return
                                }</span>
                                <span class="cov8" title="1">slog.Error("metric not found", "id", metric.ID)
                                http.Error(c.Writer, fmt.Sprintf(`metric "%s" not found`, html.EscapeString(metric.ID)), http.StatusNotFound)
                                return</span>
                        }
                case constants.CounterStr:<span class="cov8" title="1">
                        if h, err := s.HasCounter(metric.ID); err != nil || !h </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov8" title="1">{
                                        slog.Error("can't check metric existence", "id", metric.ID, "error", err)
                                        http.Error(c.Writer, `unexpected error`, http.StatusInternalServerError)
                                        return
                                }</span>
                                <span class="cov8" title="1">slog.Error("metric not found", "id", metric.ID)
                                http.Error(c.Writer, fmt.Sprintf(`metric "%s" not found`, html.EscapeString(metric.ID)), http.StatusNotFound)
                                return</span>
                        }
                default:<span class="cov8" title="1">
                        slog.Error("Invalid type", "type", metric.MType)
                        http.Error(c.Writer, fmt.Sprintf(
                                "Invalid type, only %s and %s supported",
                                constants.GaugeStr,
                                constants.CounterStr,
                        ), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov8" title="1">c.Set(contextMetricResponseKey, metric)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "compress/gzip"
        "io"

        "github.com/gin-gonic/gin"
)

// compressWriter реализует интерфейс http.ResponseWriter и позволяет прозрачно для сервера
// сжимать передаваемые данные и выставлять правильные HTTP-заголовки
type compressWriter struct {
        gin.ResponseWriter
        zw *gzip.Writer
}

func newCompressWriter(w gin.ResponseWriter) *compressWriter <span class="cov0" title="0">{
        return &amp;compressWriter{
                ResponseWriter: w,
                zw:             gzip.NewWriter(w),
        }
}</span>

func (c *compressWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        return c.zw.Write(p)
}</span>

func (c *compressWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        if statusCode &lt; 300 </span><span class="cov0" title="0">{
                c.ResponseWriter.Header().Set("Content-Encoding", "gzip")
        }</span>
        <span class="cov0" title="0">c.ResponseWriter.WriteHeader(statusCode)</span>
}

// Close закрывает gzip.Writer и досылает все данные из буфера.
func (c *compressWriter) Close() error <span class="cov0" title="0">{
        return c.zw.Close()
}</span>

// compressReader реализует интерфейс io.ReadCloser и позволяет прозрачно для сервера
// декомпрессировать получаемые от клиента данные
type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

func newCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov0" title="0">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

func (c compressReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return c.zr.Read(p)
}</span>

func (c *compressReader) Close() error <span class="cov0" title="0">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.zr.Close()</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "bytes"
        "crypto/rsa"
        "io"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/rsacrypt"
)

// cryptoReader реализует интерфейс io.ReadCloser и позволяет прозрачно для сервера
// декриптировать получаемые от клиента данные
type cryptoReader struct {
        r io.ReadCloser
        b *bytes.Buffer
        k *rsa.PrivateKey
}

func newCryptoReader(r io.ReadCloser, k *rsa.PrivateKey) (*cryptoReader, error) <span class="cov8" title="1">{
        b1 := new(bytes.Buffer)
        _, err := b1.ReadFrom(r)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b2, err := rsacrypt.DecryptWithPrivateKey(b1.Bytes(), k)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b3 := bytes.NewBuffer(b2)

        return &amp;cryptoReader{
                r: r,
                b: b3,
                k: k,
        }, nil</span>
}

func (c *cryptoReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return c.b.Read(p)
}</span>

func (c *cryptoReader) Close() error <span class="cov8" title="1">{
        if err := c.r.Close(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "crypto/rsa"
        "errors"
        "log/slog"
        "net/http"

        "github.com/gin-gonic/gin"
)

// NewDecryptBodyHandler save metric batch to a storage
func NewDecryptBodyHandler(k *rsa.PrivateKey) func(c *gin.Context) <span class="cov8" title="1">{
        decryptBodyHandler := func(c *gin.Context) </span><span class="cov8" title="1">{
                if k != nil </span><span class="cov8" title="1">{
                        // оборачиваем тело запроса в io.Reader с поддержкой декриптографирования
                        cr, err := newCryptoReader(c.Request.Body, k)
                        if err != nil </span><span class="cov8" title="1">{
                                slog.Error("can't decrypt body", "error", err)
                                _ = c.AbortWithError(http.StatusBadRequest, errors.New("can't decrypt body"))
                                return
                        }</span>
                        <span class="cov8" title="1">defer cr.Close()
                        // меняем тело запроса на новое
                        c.Request.Body = cr</span>
                }
                <span class="cov8" title="1">c.Next()</span>
        }
        <span class="cov8" title="1">return decryptBodyHandler</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

// GzipCompressionHandler middleware
func GzipCompressionHandler(c *gin.Context) <span class="cov0" title="0">{
        // по умолчанию устанавливаем оригинальный http.ResponseWriter как тот,
        // который будем передавать следующей функции
        ow := c.Writer

        // проверяем, что клиент умеет получать от сервера сжатые данные в формате gzip
        acceptEncoding := c.GetHeader("Accept-Encoding")
        supportsGzip := strings.Contains(acceptEncoding, "gzip")
        if supportsGzip </span><span class="cov0" title="0">{
                // оборачиваем оригинальный http.ResponseWriter новым с поддержкой сжатия
                cw := newCompressWriter(c.Writer)
                cw.Header().Set("Content-Encoding", "gzip")
                // не забываем отправить клиенту все сжатые данные после завершения middleware
                defer cw.Close()
                // меняем оригинальный http.ResponseWriter на новый
                ow = cw
        }</span>

        <span class="cov0" title="0">c.Writer = ow

        // проверяем, что клиент отправил серверу сжатые данные в формате gzip
        contentEncoding := c.GetHeader("Content-Encoding")
        sendsGzip := strings.Contains(contentEncoding, "gzip")
        if sendsGzip </span><span class="cov0" title="0">{
                // оборачиваем тело запроса в io.Reader с поддержкой декомпрессии
                cr, err := newCompressReader(c.Request.Body)
                if err != nil </span><span class="cov0" title="0">{
                        c.Writer.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">defer cr.Close()
                // меняем тело запроса на новое
                c.Request.Body = cr</span>
        }

        // передаём управление хендлеру
        <span class="cov0" title="0">c.Next()</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/cryptofacade"
        "github.com/gin-gonic/gin"
)

// hashWriter реализует интерфейс http.ResponseWriter и позволяет прозрачно для сервера
// посчитать хеш записанного в него тела.
type hashWriter struct {
        gin.ResponseWriter
        body []byte
}

func newHashWriter(w gin.ResponseWriter) *hashWriter <span class="cov0" title="0">{
        return &amp;hashWriter{
                ResponseWriter: w,
                body:           make([]byte, 0),
        }
}</span>

func (c *hashWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        c.body = append(c.body, p...)
        return len(p), nil
}</span>

func (c *hashWriter) GetHash(key string) string <span class="cov0" title="0">{
        return cryptofacade.Hash(c.body, []byte(key))
}</span>

func (c *hashWriter) WriteReally() (int, error) <span class="cov0" title="0">{
        return c.ResponseWriter.Write(c.body)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "fmt"
        "log/slog"
        "net/http"
)

// NewIndexHandler list all stored metrics
func NewIndexHandler(ms Storage) http.HandlerFunc <span class="cov8" title="1">{
        const (
                pageTemplate = `&lt;html&gt;&lt;body&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td colspan=2&gt;Gauges&lt;/td&gt;&lt;/tr&gt;
%s&lt;tr&gt;&lt;td colspan=2&gt;counters&lt;/td&gt;&lt;/tr&gt;
%s&lt;/table&gt;
&lt;/body&gt;&lt;/html&gt;
`
                rowTemplate = `&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;
`
        )

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        slog.Error("GET requests only", `requested`, r.Method)
                        http.Error(w, "GET requests only", http.StatusMethodNotAllowed)
                        return
                }</span>
                <span class="cov8" title="1">slog.Info("showing index")

                l, err := ms.ListGauges()
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't list gauges", "error", err)
                        http.Error(w, `unexpected error`, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">gauges := ""
                for _, key := range l </span><span class="cov8" title="1">{
                        v, errStupidLinter := ms.GetGauge(key)
                        if errStupidLinter != nil </span><span class="cov0" title="0">{
                                slog.Error("can't get gauge", "name", key, "error", errStupidLinter)
                                http.Error(w, `unexpected error`, http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">gauges += fmt.Sprintf(rowTemplate, key, fmt.Sprint(v))</span>
                }

                <span class="cov8" title="1">l, err = ms.ListCounters()
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't list counters", "error", err)
                        http.Error(w, `unexpected error`, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">counters := ""
                for _, key := range l </span><span class="cov8" title="1">{
                        v, err := ms.GetCounter(key)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("can't get counter", "name", key, "error", err)
                                http.Error(w, `unexpected error`, http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">counters += fmt.Sprintf(rowTemplate, key, fmt.Sprintf("%d", v))</span>
                }

                <span class="cov8" title="1">w.Header().Set("Content-Type", "text/html")
                _, _ = w.Write([]byte(fmt.Sprintf(pageTemplate, gauges, counters)))

                slog.Info("Processed OK")</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
)

type (
        // берём структуру для хранения сведений об ответе
        loggingResponseData struct {
                status int
                size   int
        }

        // добавляем реализацию http.ResponseWriter
        loggingResponseWriter struct {
                gin.ResponseWriter // встраиваем оригинальный http.ResponseWriter
                responseData       *loggingResponseData
        }
)

func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        // записываем ответ, используя оригинальный http.ResponseWriter
        size, err := r.ResponseWriter.Write(b)
        r.responseData.size += size // захватываем размер
        return size, err
}</span>

func (r *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        // записываем код статуса, используя оригинальный http.ResponseWriter
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode // захватываем код статуса
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package handlers

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "reflect"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/gin-gonic/gin"
)

const (
        contextMetricResponseKey = "apimodels.Metrics"
)

// MetricValueResponseHandler respond with current metric value
// Previous handler should add valid metric to context
func MetricValueResponseHandler(s Storage) func(c *gin.Context) <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                var metric *apimodels.Metrics
                metricWrapped, ok := c.Get(contextMetricResponseKey)
                if !ok </span><span class="cov8" title="1">{
                        slog.Error("No value in context", "key", contextMetricResponseKey)
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">metric, ok = metricWrapped.(*apimodels.Metrics)
                if !ok </span><span class="cov8" title="1">{
                        slog.Error("value in context is not a metric", "key", contextMetricResponseKey, "type", reflect.TypeOf(metricWrapped))
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">switch metric.MType </span>{
                case constants.GaugeStr:<span class="cov8" title="1">
                        gauge, err := s.GetGauge(metric.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                slog.Error("can't get gauge", "id", metric.ID, "error", err)
                                http.Error(c.Writer, `unexpected error`, http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">metric.Value = &amp;gauge</span>
                case constants.CounterStr:<span class="cov8" title="1">
                        counter, err := s.GetCounter(metric.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                slog.Error("can't get counter", "id", metric.ID, "error", err)
                                http.Error(c.Writer, `unexpected error`, http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">counter64 := int64(counter)
                        metric.Delta = &amp;counter64</span>
                default:<span class="cov8" title="1">
                        c.Next()
                        return</span>
                }

                // Have to set headers *before* writing to body
                <span class="cov8" title="1">c.Header("Content-Type", "application/json")
                // IRL just use c.IndentedJSON(200, metric)
                // Use encoder manually
                enc := json.NewEncoder(c.Writer)
                enc.SetIndent("", "  ")
                if err := enc.Encode(metric); err != nil </span><span class="cov0" title="0">{
                        slog.Error(err.Error())
                }</span>

                <span class="cov8" title="1">c.Next()
                slog.Info("Processed OK")</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package handlers

import (
        "log/slog"
        "net/http"

        "github.com/gin-gonic/gin"
)

type Pingable interface {
        Ping() error
}

// NewPingDBHandler create handler to check DB connection
func NewPingDBHandler(db Pingable) func(c *gin.Context) <span class="cov0" title="0">{
        pingDBHandler := func(c *gin.Context) </span><span class="cov0" title="0">{
                if db == nil </span><span class="cov0" title="0">{
                        slog.Error("DATABASE_DSN is empty")
                        http.Error(c.Writer, "DATABASE_DSN is empty", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("DB connection lost", "error", err)
                        http.Error(c.Writer, "DB connection lost", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">c.Header("Content-Type", "text/plain")
                if _, err := c.Writer.Write([]byte("OK")); err != nil </span><span class="cov0" title="0">{
                        slog.Error("response write error", "error", err)
                }</span>

                <span class="cov0" title="0">slog.Info("Processed OK")</span>
        }

        <span class="cov0" title="0">return pingDBHandler</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package handlers

import (
        "log/slog"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/gin-gonic/gin"
)

// NewRespondWithHashHandler validate hash header and
func NewRespondWithHashHandler(key string) func(c *gin.Context) <span class="cov0" title="0">{
        validateHashHandler := func(c *gin.Context) </span><span class="cov0" title="0">{
                if isHashPresent, ok := c.Get(IsHashPresent); !ok || !isHashPresent.(bool) </span><span class="cov0" title="0">{
                        slog.Info("Hash is not present in context")
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">newWriter := newHashWriter(c.Writer)
                c.Writer = newWriter
                c.Next()

                hash := newWriter.GetHash(key)
                slog.Info("setting header", "header", constants.HeaderHashSHA256, "value", hash)
                c.Header(constants.HeaderHashSHA256, hash)
                if _, err := newWriter.WriteReally(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("error writing response", "error", err)
                }</span>
        }
        <span class="cov0" title="0">return validateHashHandler</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package handlers

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/gin-gonic/gin"
)

// SaveMetricHandler save metric to storage
func SaveMetricHandler(s Storage) func(c *gin.Context) <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                metric := &amp;apimodels.Metrics{}

                // IRL just use err := c.BindJSON(&amp;metric); and c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
                // use json and http on our own
                dec := json.NewDecoder(c.Request.Body)
                if err := dec.Decode(metric); err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't parse JSON", "error", err)
                        http.Error(c.Writer, "Invalid JSON", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">err := s.SaveCommonModel(metric)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't save metric", "error", err)
                        _ = c.AbortWithError(http.StatusBadRequest, err)
                        return
                }</span>

                <span class="cov0" title="0">c.Set(contextMetricResponseKey, metric)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package handlers

import (
        "context"
        "errors"
        "log/slog"
        "net/http"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/gin-gonic/gin"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
)

type Retryer interface {
        Try(ctx context.Context, do func() error, isRetryable func(err error) bool) (int, error)
}

// SaveMetricsHandler save metric batch to a storage
func SaveMetricsHandler(s Storage, retryer Retryer) func(c *gin.Context) <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                metrics := []apimodels.Metrics{}

                if err := c.BindJSON(&amp;metrics); err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't parse JSON", "error", err)
                        _ = c.AbortWithError(http.StatusBadRequest, errors.New("can't parse JSON"))
                        return
                }</span>

                <span class="cov0" title="0">if _, err := retryer.Try(c, func() error </span><span class="cov0" title="0">{ return s.SaveCommonModels(c, metrics) }</span>, isPgConnectionError); err != nil <span class="cov0" title="0">{
                        slog.Error("can't save metrics", "error", err)
                        _ = c.AbortWithError(http.StatusBadRequest, errors.New("can't save metrics"))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"savedCount": len(metrics)})
                c.Next()</span>
        }
}

func isPgConnectionError(err error) bool <span class="cov0" title="0">{
        var pgErr *pgconn.PgError
        if errors.As(err, &amp;pgErr); pgErr != nil &amp;&amp; pgerrcode.IsConnectionException(pgErr.Code) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package handlers

import (
        "log/slog"
        "time"

        "github.com/gin-gonic/gin"
)

// SlogHandler gin middleware
func SlogHandler(c *gin.Context) <span class="cov0" title="0">{
        start := time.Now()

        responseData := &amp;loggingResponseData{
                status: 0,
                size:   0,
        }
        lw := &amp;loggingResponseWriter{
                ResponseWriter: c.Writer, // встраиваем оригинальный gin.ResponseWriter
                responseData:   responseData,
        }

        c.Writer = lw
        // передаём управление хендлеру
        c.Next()

        duration := time.Since(start)

        slog.Info("HTTP request processed",
                "uri", c.Request.RequestURI,
                "method", c.Request.Method,
                "status", responseData.status, // получаем перехваченный код статуса ответа
                "duration", duration.String(),
                "size", responseData.size, // получаем перехваченный размер ответа
        )
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package handlers

import (
        "errors"
        "fmt"
        "html"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/apimodels"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/gin-gonic/gin"
)

const (
        URLParamType  = "type"
        URLParamName  = "name"
        URLParamValue = "value"
)

// NewUpdateMetricHandler update single metric value
//
// #Deprecated: for old lesson
func NewUpdateMetricHandler(s Storage) func(c *gin.Context) <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                mType := c.Param(URLParamType)
                mName := c.Param(URLParamName)
                mValue := c.Param(URLParamValue)
                slog.Info("Processing update", "type", mType, "name", mName, "value", mValue)

                if mName == "" </span><span class="cov8" title="1">{
                        slog.Error("Metric not found")
                        _ = c.AbortWithError(http.StatusNotFound, errors.New("metric not found"))
                        return
                }</span>

                <span class="cov8" title="1">metric := apimodels.Metrics{ID: mName, MType: mType}

                switch mType </span>{
                case constants.GaugeStr:<span class="cov8" title="1">
                        floatValue, err := strconv.ParseFloat(mValue, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                slog.Error("Invalid metric value, float64 required", `value`, html.EscapeString(mType))
                                _ = c.AbortWithError(http.StatusBadRequest, errors.New("invalid metric value"))
                                return
                        }</span>
                        <span class="cov8" title="1">metric.Value = &amp;floatValue</span>
                case constants.CounterStr:<span class="cov8" title="1">
                        intValue, err := strconv.Atoi(mValue)
                        if err != nil </span><span class="cov8" title="1">{
                                slog.Error("Invalid metric value, integer required", `value`, html.EscapeString(mType))
                                _ = c.AbortWithError(http.StatusBadRequest, errors.New("invalid metric value"))
                                return
                        }</span>
                        <span class="cov8" title="1">int64Value := int64(intValue)
                        metric.Delta = &amp;int64Value</span>
                default:<span class="cov8" title="1">
                        slog.Error("Type is invalid", "type", html.EscapeString(mType))
                        _ = c.AbortWithError(http.StatusBadRequest, fmt.Errorf(
                                `invalid type "%s", only "%s" and "%s" are supported`,
                                html.EscapeString(mType),
                                constants.GaugeStr,
                                constants.CounterStr,
                        ))
                        return</span>
                }

                <span class="cov8" title="1">if err := s.SaveCommonModel(&amp;metric); err != nil </span><span class="cov8" title="1">{
                        slog.Error("can't update metric", "error", err)
                        _ = c.AbortWithError(http.StatusInternalServerError, errors.New("unexpected error"))
                        return
                }</span>

                <span class="cov8" title="1">c.Next()
                slog.Info("Processed OK")</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package handlers

import (
        "bytes"
        "fmt"
        "io"
        "log/slog"
        "net/http"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/fasdalf/train-go-musthave-metrics/internal/common/cryptofacade"
        "github.com/gin-gonic/gin"
)

const (
        IsHashPresent = "IsHashPresent"
)

// NewValidateHashHandler validate request hash
func NewValidateHashHandler(key string) func(c *gin.Context) <span class="cov0" title="0">{
        validateHashHandler := func(c *gin.Context) </span><span class="cov0" title="0">{
                requestHash := c.GetHeader(constants.HeaderHashSHA256)

                if requestHash == "" </span><span class="cov0" title="0">{
                        c.Set(IsHashPresent, false)
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">ByteBody, _ := io.ReadAll(c.Request.Body)
                c.Request.Body = io.NopCloser(bytes.NewBuffer(ByteBody))
                realHash := cryptofacade.Hash(ByteBody, []byte(key))

                if realHash != requestHash </span><span class="cov0" title="0">{
                        slog.Error("header value is invalid", "realHash", realHash, "requestHash", requestHash)
                        _ = c.AbortWithError(http.StatusBadRequest, fmt.Errorf("%s header value is invalid: %s", constants.HeaderHashSHA256, requestHash))
                        return
                }</span>

                <span class="cov0" title="0">c.Set(IsHashPresent, true)
                c.Next()</span>
        }
        <span class="cov0" title="0">return validateHashHandler</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package handlers

import (
        "fmt"
        "log/slog"
        "net"
        "net/http"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/gin-gonic/gin"
)

// NewValidateIPHandler validate IP header
// Trust such headers only then they're set by trusted reverse proxy.
func NewValidateIPHandler(tr *net.IPNet) func(c *gin.Context) <span class="cov8" title="1">{
        validateIPHandler := func(c *gin.Context) </span><span class="cov8" title="1">{
                if tr != nil </span><span class="cov8" title="1">{
                        ipString := c.GetHeader(constants.HeaderRealIP)
                        if err := validateIPStringInSubnet(ipString, tr); err != nil </span><span class="cov8" title="1">{
                                slog.Error("header value is invalid", "header", constants.HeaderRealIP, "error", err)
                                _ = c.AbortWithError(http.StatusForbidden, fmt.Errorf("%s header value is invalid: %s", constants.HeaderRealIP, ipString))
                                return
                        }</span>

                }

                <span class="cov8" title="1">c.Next()</span>
        }
        <span class="cov8" title="1">return validateIPHandler</span>
}

func validateIPStringInSubnet(addr string, subnet *net.IPNet) error <span class="cov8" title="1">{
        ip := net.ParseIP(addr)
        if ip == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("\"%s\" is not a valid IP address", addr)
        }</span>
        <span class="cov8" title="1">if subnet == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("empty subnet")
        }</span>
        <span class="cov8" title="1">if !subnet.Contains(ip) </span><span class="cov8" title="1">{
                return fmt.Errorf("IP address \"%s\" is not in subnet \"%s\"", addr, subnet.String())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package handlers

import (
        "errors"
        "fmt"
        "html"
        "log/slog"
        "net/http"

        "github.com/fasdalf/train-go-musthave-metrics/internal/common/constants"
        "github.com/gin-gonic/gin"
)

// NewViewStatsHandler view single stored metric
//
// #Deprecated: for old lesson
func NewViewStatsHandler(ms Storage) func(c *gin.Context) <span class="cov8" title="1">{
        // In our project we have a tradition to add single middleware to put metricstorage.Storage pointer in context.
        // Let's use handler constructors for now
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                mType := c.Param(URLParamType)
                mName := c.Param(URLParamName)
                mValue := ""
                switch mType </span>{
                case constants.GaugeStr:<span class="cov8" title="1">
                        if h, err := ms.HasGauge(mName); err != nil || !h </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("can't get gauge", "id", mName, "error", err)
                                        http.Error(c.Writer, `unexpected error`, http.StatusInternalServerError)
                                        return
                                }</span>
                                <span class="cov8" title="1">http.Error(c.Writer, fmt.Sprintf(`metric "%s" not found`, html.EscapeString(mName)), http.StatusNotFound)
                                return</span>
                        }
                        <span class="cov8" title="1">value, err := ms.GetGauge(mName)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("can't get gauge", "name", mName, "error", err)
                                _ = c.AbortWithError(http.StatusInternalServerError, errors.New(`unexpected error`))
                                return
                        }</span>
                        <span class="cov8" title="1">mValue = fmt.Sprint(value)</span>
                case constants.CounterStr:<span class="cov8" title="1">
                        if h, err := ms.HasCounter(mName); err != nil || !h </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("can't get gauge", "id", mName, "error", err)
                                        http.Error(c.Writer, `unexpected error`, http.StatusInternalServerError)
                                        return
                                }</span>
                                <span class="cov8" title="1">http.Error(c.Writer, fmt.Sprintf(`metric "%s" not found`, html.EscapeString(mName)), http.StatusNotFound)
                                return</span>
                        }
                        <span class="cov8" title="1">value, err := ms.GetCounter(mName)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("can't get counter", "name", mName, "error", err)
                                _ = c.AbortWithError(http.StatusInternalServerError, errors.New(`unexpected error`))
                                return
                        }</span>
                        <span class="cov8" title="1">mValue = fmt.Sprint(value)</span>
                default:<span class="cov8" title="1">
                        slog.Error("Invalid type", "type", mType)
                        http.Error(c.Writer, fmt.Sprintf(
                                "Invalid type, only %s and %s supported",
                                constants.GaugeStr,
                                constants.CounterStr,
                        ), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov8" title="1">c.Header(`Content-Type`, `text/plain`)
                _, _ = c.Writer.Write([]byte(mValue))
                slog.Info("got value", "type", mType, "name", mName, "value", mValue)</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package server

import (
        "crypto/rsa"
        "fmt"
        "net"

        "github.com/fasdalf/train-go-musthave-metrics/internal/server/handlers"
        "github.com/gin-gonic/gin"
)

func NewRoutingEngine(ms handlers.Storage, db handlers.Pingable, retryer handlers.Retryer, key string, decryptionKey *rsa.PrivateKey, tr *net.IPNet) *gin.Engine <span class="cov8" title="1">{
        ginCore := gin.New()
        ginCore.RedirectTrailingSlash = false
        ginCore.RedirectFixedPath = false
        ginCore.Use(gin.Recovery())
        // IRL just use ginCore.Use(slogGin.New(slog.Default())) from slogGin "github.com/samber/slog-gin"
        // "We have it at home" logging. Uses .../loggingResponseWriter.go and .../slogHandler.go
        ginCore.Use(handlers.SlogHandler)
        if key != "" </span><span class="cov8" title="1">{
                ginCore.Use(handlers.NewValidateHashHandler(key))
                ginCore.Use(handlers.NewRespondWithHashHandler(key))
        }</span>
        <span class="cov8" title="1">ginCore.Use(handlers.NewValidateIPHandler(tr))
        // IRL just use ginCore.Use(gzip.Gzip(gzip.DefaultCompression)) from "github.com/gin-contrib/gzip"
        // "We have it at home" compression. Uses .../compressWriter.go and .../gzipCompressionHandler.go
        ginCore.Use(handlers.GzipCompressionHandler)
        // IRL use regular TLS.
        // "We have it at home" RSA.
        ginCore.Use(handlers.NewDecryptBodyHandler(decryptionKey))

        ginCore.GET("/", gin.WrapF(handlers.NewIndexHandler(ms)))
        ginCore.GET("/ping", handlers.NewPingDBHandler(db))
        ginCore.GET(fmt.Sprintf("/value/:%s/:%s", handlers.URLParamType, handlers.URLParamName), handlers.NewViewStatsHandler(ms))

        valuePipeline := []gin.HandlerFunc{handlers.CheckMetricExistenceHandler(ms), handlers.MetricValueResponseHandler(ms)}
        // Path with slash is for broken test in iteration 14
        ginCore.POST("/value/", valuePipeline...)
        ginCore.POST("/value", valuePipeline...)
        ginCore.POST(fmt.Sprintf("/update/:%s/:%s/:%s", handlers.URLParamType, handlers.URLParamName, handlers.URLParamValue), handlers.NewUpdateMetricHandler(ms))
        ginCore.POST("/update/", handlers.SaveMetricHandler(ms), handlers.MetricValueResponseHandler(ms))
        ginCore.POST("/updates/", handlers.SaveMetricsHandler(ms, retryer))
        return ginCore</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
